import re

import numpy as np
import pandas as pd

import tcc_cft_tool.encode_func as ef

from tcc_cft_tool.cft_config import SPC_FTLZ_PDCT

# TODO: add template config class


class CftExcel:
    excel_sheet = {'README': {'cft_layers': None, 'columns': None},
                   '0-2 Farm-Crop-Soil': {'cft_layers': ['farm', 'crop'],
                                          'columns': ['reporting_year',
                                                      'farm_identifier',
                                                      'climate',
                                                      'average_temperature',
                                                      'crop_type',
                                                      'field_size',
                                                      'product_fresh',
                                                      'product_finished',
                                                      'residue_value',
                                                      'residue_management',
                                                      'seed_amount_value',
                                                      'soil_texture',
                                                      'soil_organic_matter',
                                                      'soil_moisture',
                                                      'soil_drainage',
                                                      'soil_ph']},
                   '3.1 Fertilizer': {'cft_layers': ['fertilisers'],
                                      'columns': ['reporting_year',
                                                  'farm_identifier',
                                                  'fertilizer_type',
                                                  'fertilizer_production',
                                                  'fertilizer_application_rate',
                                                  'fertilizer_method',
                                                  'fertilizer_inhibition',
                                                  'fertilizer_urea_pct',
                                                  'fertilizer_nitrate_pct',
                                                  'fertilizer_ammonium_pct',
                                                  'fertilizer_p_pct',
                                                  'fertilizer_k_pct']},
                   '3.2 Crop_Protection': {'cft_layers': ['pesticides'],
                                           'columns': ['reporting_year',
                                                       'farm_identifier',
                                                       'pesticides_category',
                                                       'pesticides_type',
                                                       'pesticides_application_rate',
                                                       'pesticides_percentage_rate']},
                   '4.1 Direct_Energy': {'cft_layers': ['direct_energy'],
                                         'columns': ['reporting_year',
                                                     'farm_identifier',
                                                     'direct_energy_source',
                                                     'direct_energy_value',
                                                     'direct_energy_category']},
                   '4.2 Operation_Energy': {'cft_layers': ['machinery'],
                                            'columns': ['reporting_year',
                                                        'farm_identifier',
                                                        'machinery_type',
                                                        'machinery_fuel_type',
                                                        'machinery_operations']},
                   '5 Irrigation': {'cft_layers': ['irrigation'],
                                    'columns': ['reporting_year',
                                                'farm_identifier',
                                                'irrigation_method',
                                                'irrigation_power_source',
                                                'irrigation_pumping_depth',
                                                'irrigation_pumping_distance',
                                                'irrigation_water_value',
                                                'irrigation_allocation']},
                   '6 Carbon': {'cft_layers': ['land_management'],
                                'columns': ['reporting_year',
                                            'farm_identifier',
                                            'land_management_change',
                                            'land_management_years_ago',
                                            'land_management_allocation',
                                            'forest_type',
                                            'forest_age']},
                   '7 Transport': {'cft_layers': ['transport'],
                                   'columns': ['reporting_year',
                                               'farm_identifier',
                                               'transport_mode',
                                               'transport_weight',
                                               'transport_distance']},
                   '8.1 Potato (Processing)': {'cft_layers': ['processing'],
                                               'columns': ['reporting_year',
                                                           'farm_identifier',
                                                           'processing_allocation',
                                                           'processing_type',
                                                           'processing_energy']},
                   '8.2 Potato (Storage)': {'cft_layers': ['storage'],
                                            'columns': ['reporting_year',
                                                        'farm_identifier',
                                                        'storage_allocation',
                                                        'storage_loading_power',
                                                        'storage_unloading_power',
                                                        'storage_power',
                                                        'storage_time',
                                                        'storage_temperature',
                                                        'cipc_application',
                                                        'cipc_dose']},
                   'Reference': {'cft_layers': None, 'columns': None}}
    ignored_layers = [
        "tree_biomass",
        "co_products"
    ]

    def __init__(self, cft_excel: pd.io.excel._base.ExcelFile):
        assert isinstance(cft_excel, pd.io.excel._base.ExcelFile)
        # assert sheet names match
        # TODO: add detail error message here
        sheet_name_set = set(self.excel_sheet.keys())
        mismatch_sheet_set = sheet_name_set.difference(
            set(cft_excel.sheet_names))
        self._cft_excel = cft_excel

    def generate_empty_layer(self, sheet):
        return pd.DataFrame(
            columns=["AssessmentID"] + self.excel_sheet[sheet]['cft_layers']
        ).set_index("AssessmentID")

    def get_data(self, sheet_name, columns=[]):
        df = self._cft_excel.parse(
            sheet_name=sheet_name, header=3)
        df = self.standardize_sheet(df)
        if len(columns) == 0:
            return (df)
        else:
            return (df[['reporting_year', 'farm_identifier']+columns])

    def convert_sheetname_funcname(self, sheet_name):
        return "transform_" + re.sub("-| |^\S*|\)", '', re.sub("-", "_", sheet_name)).split('(')[-1].lower()

    def transform_excel_to_request(self, skip_sheets=[]):
        for sheet in list(self.excel_sheet.keys())[1:-1]:
            assert "0-2 Farm-Crop-Soil" not in skip_sheets
            if sheet in skip_sheets:
                print(f'Skip sheet: {sheet}')
                transformed_df = self.generate_empty_layer(sheet)
            else:
                print(f'Transforming sheet: {sheet}...')
                transformed_df = self.transform_sheet_to_request(sheet)

            if sheet == "0-2 Farm-Crop-Soil":
                result_df = transformed_df
            else:
                result_df = result_df.join(transformed_df, how="outer")
        result_df = result_df.reindex(
            columns=result_df.columns.tolist() + self.ignored_layers
        )
        return (
            pd.Series(
                result_df.apply(
                    lambda x: x.apply(
                        lambda d: d
                        if (isinstance(d, list) | isinstance(d, dict))
                        else []
                    ),
                    axis=1,
                ).apply(dict, axis=1),
                name="request",
            )
            .reset_index()
            .to_dict("records")
        )

    def transform_sheet_to_request(self, sheet_name):

        df = self._cft_excel.parse(
            sheet_name=sheet_name, header=3)
        df = self.standardize_sheet(df)
        if len(df) == 0:
            print(f'{sheet_name} is empty')
            return self.generate_empty_layer(sheet_name)
        if sheet_name == "6 Carbon":
            df = df.merge(
                self.standardize_sheet(
                    self._cft_excel.parse(
                        sheet_name="0-2 Farm-Crop-Soil", header=3)
                )[
                    ["reporting_year",
                        "farm_identifier",
                        "climate",
                        "soil_moisture",
                     ]
                ],
                on=["farm_identifier", "reporting_year"],
                how="left",
            )
            df["climate"] = df["climate"].str.lower()

        request_df = (
            pd.DataFrame(
                list(
                    df.apply(
                        getattr(
                            self,
                            self.convert_sheetname_funcname(sheet_name),
                        ),
                        axis=1,
                    )
                )
            )
            .set_index("AssessmentID")
            .dropna()
        )

        if sheet_name in ["0-2 Farm-Crop-Soil", '9.1 Rice (Flooding)']:
            return request_df

        else:
            return request_df.groupby(level=0).agg(
                {cft_layer:
                    list for cft_layer in self.excel_sheet[sheet_name]['cft_layers']}
            )

    def standardize_sheet(self, df: pd.DataFrame):
        df = df.dropna(subset=["farm_identifier"])
        df = df[~df['farm_identifier'].str.contains("^\*\*")]
        if len(df) > 0:
            df = df[df.drop(columns=['country', 'reporting_year',
                            'farm_identifier']).notna().apply(any, axis=1)]
        df["farm_identifier"] = df["farm_identifier"].str.strip().str.upper()
        df = df.astype(object).replace(np.nan, None)
        df['farm_identifier'] = df['farm_identifier'].astype(str)
        df['reporting_year'] = df['reporting_year'].astype(int)
        return df

    def transform_farm_crop_soil(self, sr):
        farm_crop_soil_dict = {
            "AssessmentID": "::".join(
                list(sr[["farm_identifier", "reporting_year"]].astype(str))
            ),
            "farm": {
                "average_temperature": {
                    "value": sr["average_temperature"]
                    if sr["average_temperature"] != None else ef.get_default_temp(sr["climate"]),
                    "unit": 5,  # 5 - celsius degree
                },
                "climate": ef.encode_climate(sr["climate"]),

                "country": sr['country'],
                "farm_identifier": sr["farm_identifier"],
                "territory": None
            },
            "crop": {
                "product_fresh": {"value": sr["product_fresh"], "unit": 7},
                "product_finished": {
                    "value": sr["product_finished"],
                    "unit": 7,  # 7 - kg
                },
                "type": sr["crop_type"],
                "field_size": {
                    "value": sr["field_size"],
                    "unit": 10,  # 10 - ha
                },
                "soil": {
                    "texture_id": ef.encode_soil_texture(sr["soil_texture"]),
                    "organic_matter_id": 5,  # custom value
                    'organic_matter_custom': 'None' if sr["soil_organic_matter"] == None else sr["soil_organic_matter"],
                    "moisture_id": ef.encode_soil_moisture(sr["soil_moisture"]),
                    "drainage_id": ef.encode_soil_drainage(sr["soil_drainage"]),
                    "ph_id": None if sr["soil_ph"] == None else ef.encode_soil_ph(sr["soil_ph"]),
                },
                "residue": {
                    "value": sr["residue_value"],
                    "unit": 24,  # 24 - kg/ha
                    "management": ef.encode_residue_management(
                        sr["residue_management"]
                    ),
                },
                "seed_amount": {},
                "irrigation_calculation_type": 2,

            },
        }
        if ef.encode_crop_type(sr["crop_type"]) == 14:
            farm_crop_soil_dict['crop'].update({"seed_amount": {
                'value': sr['seed_amount_value'],
                'unit': 7  # 7 - kg
            }})
        return farm_crop_soil_dict

    def transform_fertilizer(self, sr):
        production = SPC_FTLZ_PDCT[sr["fertilizer_type"]] if sr["fertilizer_type"] in SPC_FTLZ_PDCT.keys(
        ) else sr["fertilizer_production"]
        fertilizer_dict = {
            "AssessmentID": "::".join(
                list(sr[["farm_identifier", "reporting_year"]].astype(str))
            ),
            "fertilisers": {
                "type": sr["fertilizer_type"],
                "production": production,
                "application_rate": {
                    "value": sr["fertilizer_application_rate"],
                    "unit": 24,  # kg / ha
                },
                "inhibition_id": ef.encode_fertilizer_inhibition(
                    sr["fertilizer_inhibition"]
                ),
                "method": ef.encode_fertilizer_method(sr["fertilizer_method"]),
                "rate_measure": 'product',
                "custom_ingredients": {},
            },
        }

        if sr["fertilizer_type"] == "Compose your own NPK":
            sr = sr.fillna(0)
            sr[
                ['fertilizer_urea_pct', 'fertilizer_nitrate_pct',
                 'fertilizer_ammonium_pct',]
            ] = sr[
                ['fertilizer_urea_pct', 'fertilizer_nitrate_pct',
                 'fertilizer_ammonium_pct',]
            ].astype(float).round(2)
            fertilizer_dict["fertilisers"].update(
                {
                    "custom_ingredients": {
                        "n_total_percentage": round(sr[
                            ['fertilizer_urea_pct', 'fertilizer_nitrate_pct',
                                'fertilizer_ammonium_pct',]
                        ].sum(),2),
                        "n_ammonia_percentage": sr["fertilizer_ammonium_pct"],
                        "n_nitric_percentage": sr["fertilizer_nitrate_pct"],
                        "n_urea_percentage": sr["fertilizer_urea_pct"],
                        "p2o5_percentage": sr["fertilizer_p_pct"],
                        "p2o5_percentage_type_id": 2,
                        "k2o_percentage": sr["fertilizer_k_pct"],
                        "k2o_percentage_type_id": 5,
                    }
                }
            )
        return fertilizer_dict

    def transform_crop_protection(self, sr):
        crop_protection_dict = {
            "AssessmentID": "::".join(
                list(sr[["farm_identifier", "reporting_year"]].astype(str))
            ),
            "pesticides": {
                'applications': 1,
                "application_rate": {
                    "value": sr["pesticides_application_rate"],
                    "unit": 24,  # kg / ha
                },
                "type_id": ef.encode_pesticide_type(sr["pesticides_type"]),
                "category_id": ef.encode_pesticide_category(sr["pesticides_category"]),
                "percentage_rate": None if sr["pesticides_percentage_rate"] == None else int(sr["pesticides_percentage_rate"])
            },
        }
        return crop_protection_dict

    def transform_operation_energy(self, sr):
        return {
            "AssessmentID": "::".join(
                list(sr[["farm_identifier", "reporting_year"]].astype(str))
            ),
            "machinery": {
                "fuel_type": ef.encode_direct_energy_type(sr["machinery_fuel_type"].strip()),
                "machinery": sr["machinery_type"],
                "operations": sr["machinery_operations"],
            },
        }

    def transform_irrigation(self, sr):
        return {
            "AssessmentID": "::".join(
                list(sr[["farm_identifier", "reporting_year"]].astype(str))
            ),
            "irrigation": {
                "allocation": sr["irrigation_allocation"],
                "horizontal_distance": {
                    "value": 0,
                    "unit": 1,  # 1 - m
                },
                "pumping_depth": {
                    "value": 0,
                    "unit": 1,  # 1 - m
                },
                "method": ef.encode_irrigation_method(sr["irrigation_method"]),
                "power_source": ef.encode_irrigation_power_source(sr["irrigation_power_source"]),
                "water_added": {
                    "value": sr["irrigation_water_value"],
                    "unit": 15,  # 15 - litre
                },
            },
        }

    def transform_processing(self, sr):
        return {
            "AssessmentID": "::".join(
                list(sr[["farm_identifier", "reporting_year"]].astype(str))
            ),
            "processing": {
                "_type": ef.encode_processing_type(sr['processing_type']),
                "power_source": ef.encode_direct_energy_type(sr["processing_energy"]),
                "allocation": sr["processing_allocation"],
            },
        }

    def transform_storage(self, sr):
        return {
            "AssessmentID": "::".join(
                list(sr[["farm_identifier", "reporting_year"]].astype(str))
            ),
            "storage": {
                "cipc_dose": sr["cipc_dose"],
                "cipc_application": sr["cipc_application"],
                'storage_power_source': ef.encode_direct_energy_type(sr["storage_power"]),
                'store_loading_power_source': ef.encode_direct_energy_type(sr["storage_loading_power"]),
                "unloading_power_source": ef.encode_direct_energy_type(sr["storage_unloading_power"]),
                'stored_allocation': sr['storage_allocation'],
                "temperature": {'value': sr['storage_temperature'],
                                'unit': 5  # 5 - C
                                },
                'time': {
                    'value': sr['storage_time'],
                    'unit': 48
                },
            },
        }

    def transform_carbon(self, sr):
        return {
            "AssessmentID": "::".join(
                list(sr[["farm_identifier", "reporting_year"]].astype(str))
            ),
            "land_management": {
                "change_id": ef.encode_land_management(
                    "_".join(
                        list(
                            sr[["land_management_change", "climate", "soil_moisture"]].astype(str))
                    )
                ),
                "years_ago": sr["land_management_years_ago"],
                "allocation": sr["land_management_allocation"],
                "forest": {},
            },
        }

    def transform_transport(self, sr):
        return {
            "AssessmentID": "::".join(
                list(sr[["farm_identifier", "reporting_year"]].astype(str))
            ),
            "transport": {
                "mode": sr['transport_mode'],
                "weight": {'value': round(sr["transport_weight"], 2), 'unit': 7},
                "distance": {'value': round(sr["transport_distance"], 2), 'unit': 2}
            },
        }

    def transform_direct_energy(self, sr):
        energy_type, unit = tuple(sr['direct_energy_source'].split(' - '))
        return {
            "AssessmentID": "::".join(
                list(sr[["farm_identifier", "reporting_year"]].astype(str))
            ),
            "direct_energy": {
                'category': ef.encode_energy_category(sr['direct_energy_category']),
                "source": ef.encode_direct_energy_type(energy_type),
                'usage': {
                    "value": sr["direct_energy_value"],
                    "unit": ef.encode_general_unit(unit),

                }
            }
        }

    def transform_flooding(self, sr):
        return {
            "AssessmentID": "::".join(
                list(sr[["farm_identifier", "reporting_year"]].astype(str))
            ),
            "flooding": {
                "time_under_cultivation": {'value': round(sr["cultivation_time"], 2), 'unit': 48},
                "before_cultivation": sr['before_water'],
                "during_cultivation": sr["during_water"]
            },
        }


def parse_assessmentid(df):
    field_index_df = df["AssessmentID"].str.split("::", expand=True)
    field_index_df.columns = ['farm_identifier', 'reporting_year']
    field_index_df['reporting_year'] = field_index_df['reporting_year'].astype(
        'int')
    return pd.concat([field_index_df, df.drop("AssessmentID", axis=1)], axis=1)