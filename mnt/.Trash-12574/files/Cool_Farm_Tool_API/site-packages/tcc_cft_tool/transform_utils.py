##
#   Functions of transforming raw input csv to formated api-request json
#   and return-json to result csv
#   Author: Yafan Tang

import numpy as np
import pandas as pd
import re


def dq_control(df):
    """
    Data quality checking and fixing function, will keep add functions as need.

    Parameters
    ----------
    df: pandas.DataFrame
        Tabulated input data based on sample CSV template.
        Template:
        https://docs.google.com/spreadsheets/d/1OU-NCJMGXkzmsT7hHFfJSn7hcGxx6uurMeyv4zTgK0I/edit?usp=sharing
    Return
    ----------
    : pandas.DataFrame
    """

    def _correct_dtypes(x):
        try:
            x = float(x)
            if (x % 1) == 0:
                x = int(x)
            if np.isnan(x):
                x = None
        except ValueError:
            pass
        return x

    df = df.copy()
    assert set(df.columns) == {'Class', 'AssessmentID',
                               'Property', 'Table', 'Value', 'Class Index'}
    df['Value'] = df['Value'].apply(_correct_dtypes)

    # Fix Typos
    df['Class'].replace('pumping', 'pumping_depth', inplace=True)
    df.loc[(df['Table'] == 'pesticides') & (df['Property'] == 'category'),
           ['Class', 'Property']] = 'category_id'

    # Unit test for duplicate data fields
    assert not df.drop(columns='Value').duplicated().any()
    # confirm all "percentage" inputs are not fractions (0-1)
    # wpct = df['Property'].fillna('nan').str.endswith('percentage')
    # assert df[wpct]['Value'].max() == 100
    return df


def input_to_request(input_df):
    """
    transform long format dataframe to nested dataframe, each row having ready-to-use json request
    and corresponding field id

    Parameters
    ----------
    input_df: pandas.DataFrame
    Return
    ----------
    output_df: pandas.DataFrame
    """
    def property_value_to_dict(df):
        '''
        Covert columns `property` & `value` in `df` to dict.
        '''
        if len(df.dropna(subset=['Property'])) == 0:
            return None
        # handling both unit and application rate are None
        elif all(df['Value'].isna()) and len(df['Value']) > 1:
            return {}
        return dict(zip(df.Property, df.Value))

    def class_to_dict(df):
        '''
        Covert column `0` (dict generated from `property_value_to_dict`)
        and `class` in `df` to dict.
        '''
        if len(df[['Class', 0]].dropna()) == 0:
            return None
        _dict = dict(zip(df['Class'], df[0]))
        # if class and property is the same
        # don't make it into nested json
        for key, value in _dict.items():
            if key in value.keys():
                _dict[key] = value[key]
        return _dict

    def class_index_to_ls(df):
        '''
        Covert column `0` (dict generated from `class_to_dict`) to list
        '''
        # some features may have multiple records,
        # make them into list
        if len(df[['Class Index', 0]].dropna()) == 0:
            return []
        return df[0].tolist()

    def table_to_dict(df):
        '''
        Covert column `0` (ls generated from `class_index_to_ls`) to dict.
        '''
        list_features = ["pesticides",
                         "fertilisers",
                         "machinery",
                         "irrigation",
                         "direct_energy",
                         "land_management",
                         "transport",
                         "tree_biomass",
                         "co_products",
                         "processing",
                         "storage"]
        _dict = dict(zip(df['Table'], df[0]))
        # if feature not a list feature listed above
        # it only has one item, so remove []
        for key, value in _dict.items():
            if key not in list_features:
                _dict[key] = _dict[key][0]
        # impute missing features with []
        for list_feature in list_features:
            if list_feature not in _dict.keys():
                _dict[list_feature] = []
        return _dict

    output_df = (input_df.groupby(['AssessmentID', 'Table', 'Class Index', 'Class']).apply(property_value_to_dict).to_frame().reset_index()
                 .groupby(['AssessmentID', 'Table', 'Class Index'], sort=False).apply(class_to_dict).to_frame().reset_index()
                 .groupby(['AssessmentID', 'Table'], sort=False).apply(class_index_to_ls).to_frame().reset_index()
                 .groupby(['AssessmentID'], sort=False).apply(table_to_dict).to_frame().reset_index()
                 .rename(columns={0: 'request'}))
    return output_df


def parse_summary(result_ls):
    """
    Parse CFT api return: summary of carbon emission

    Parameters
    ----------
    result_ls: list of dict

    Return
    ----------
    : pandas.DataFrame
      Summary result in a df
    """

    def _parse_value(value):
        """
        Parse the input list or string
        for example: [144.71,'kg CO2e / lb'], 4.49%

        Parameters
        ----------
        value: list or str

        Return
        ----------
        value_dict: dict

        """
        if isinstance(value, list):
            value_dict = {'value': float(value[0]),
                          'unit': value[1].replace(' ', '')}
        elif isinstance(value, str):
            num = '.'.join(re.findall('\d+', value))
            value_dict = {'value': float(num),
                          'unit': value.replace(num, '').replace(" ", '')}
        return value_dict

    def _parse_summary(field_dict):
        """
        Parse returned GHG summary for a field

        Parameters
        ----------
        field_dict: dict

        Return
        ----------
        : pandas.DataFrame

        """
        result_ls = []
        for key, value in field_dict['return']['summary'].items():
            _dict = {'AssessmentID': field_dict['AssessmentID'], 'result': key}
            _dict.update(_parse_value(value))
            result_ls.append(_dict)
        return pd.DataFrame(result_ls)

    summary_ls = []
    for field_dict in result_ls:
        if ('error' not in str(field_dict['return'])) & (field_dict['return'] is not None):
            field_df = _parse_summary(field_dict)
            summary_ls.append(field_df)
    return pd.concat(summary_ls)


def parse_detail(result_ls):
    """
    Parse CFT api return in more detail regarding different
    emission sources and green house gas.

    Parameters
    ----------
    result_ls: list of dict

    Return
    ----------
    : pandas.DataFrame
      More detail of GHG result in a df
    """
    detail_ls = []
    for field_dict in result_ls:
        if ('error' not in str(field_dict['return'])) & (field_dict['return'] is not None):
            detail_df = (pd.json_normalize(field_dict['return'],
                                           record_path='total_emissions')
                         .rename(columns={'name': 'source'}))
            detail_df = detail_df.apply(pd.to_numeric, errors='ignore')
            detail_df.insert(0, 'AssessmentID', field_dict['AssessmentID'])
            detail_ls.append(detail_df)
    return pd.concat(detail_ls)

def parse_assessmentid(df):
    field_index_df = df["AssessmentID"].str.split("_", expand=True)
    field_index_df.columns = ["Field Name", "Country", "Geography", "Harvest Year"]
    return pd.concat([field_index_df, df.drop("AssessmentID", axis=1)], axis=1)